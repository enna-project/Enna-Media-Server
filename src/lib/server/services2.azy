
Azy_Namespace ems;

Azy_Module Serve {


<%
	#include <stdio.h>
	#include <string.h>

	#include "global.h"
	#include "network_service.h"
	#include "samba_share.h"
	#include "samba_user.h"
	#include "samba_group.h"
	#include "backup.h"
	#include "restore.h"
%>

	__init__
<%
	(void)module;
	printf("Accepted connection from: %s\n", azy_net_ip_get(net_));
%>


	__post__
<%
	return EINA_TRUE;
%>


	__download__
<%
#define DL_ERROR                                                              \
	got_error = EINA_TRUE;                                                    \
	goto download_end_uri;
	const char  *path,
	            *content   = NULL;
	char **split = NULL;
	Azy_Net_Data azy_data;
	unsigned int nb_params,
	             i;
	Eina_Bool got_error = EINA_FALSE;
	struct download_lookup {
        const char *uri;
        unsigned int nb_params;
        const char *(*func)(const char *name);
    };
    struct download_lookup download_lkt[] = {
		{ "/network/services/list", 4, network_service_list },
		{ "/network/services/get" , 5, network_service_get  },
		{ "/samba/shares/list"    , 4, samba_share_list     },
		{ "/samba/shares/get"     , 5, samba_share_get      },
		{ "/samba/shares/delete"  , 5, samba_share_delete   },
		{ "/samba/users/list"     , 4, samba_user_list      },
		{ "/samba/users/get"      , 5, samba_user_get       },
		{ "/samba/users/delete"   , 5, samba_user_delete    },
		{ "/samba/groups/list"    , 4, samba_group_list     },
		{ "/samba/groups/get"     , 5, samba_group_get      },
		{ "/samba/groups/delete"  , 5, samba_group_delete   },
		{ "/backup"               , 2, backup               },
		{ NULL                    , 0, NULL                 }
    };

	path = azy_net_uri_get(net_);
	if( *path != '/' ) {
		DL_ERROR;
	}
	split = eina_str_split_full(path,
	                            "/",
	                            10,
	                            &nb_params);

	for( i = 0; download_lkt[i].uri; i++ ) {
        if( !strncmp(download_lkt[i].uri, path, strlen(download_lkt[i].uri)) ) {
            const char *given_param = NULL;

            if( ( download_lkt[i].nb_params == 5 ) &&
			    ( nb_params > 4 ) )
                given_param = split[4];

            content = download_lkt[i].func(given_param);
            goto download_end_uri;
        }

    }

    DL_ERROR;

	download_end_uri:
	if( got_error == EINA_TRUE ) {
		azy_net_code_set(net_, 400);
		azy_net_header_set(net_, "Content-Type", "text/plain");
		content = eina_stringshare_add("Bad request");
	} else {
		azy_net_code_set(net_, 200);
		azy_net_header_set(net_, "Content-Type", "Application/json");
	}
	azy_data.data = (unsigned char *)content;
	azy_data.size = strlen(content);

	if( split ) {
		free(split[0]);
		free(split);
	}
	azy_server_module_send(module, net_, &azy_data);
	if( content ) eina_stringshare_del(content);
	return EINA_TRUE;
#undef DL_ERROR
%>



	__upload__
<%
#define UPLOAD_ERROR                                                          \
	got_error = EINA_TRUE;                                                    \
	goto upload_end_uri;
	const char  *path,
	            *content = NULL;
    char **split = NULL,
	      *uploaded_data = NULL;
	Azy_Net_Data *data_recv,
	              data_send;
	unsigned int nb_params,
	             i;
	Eina_Bool got_error = EINA_FALSE;
	struct upload_lookup {
		const char *uri;
		unsigned int nb_params;
		const char *(*func)(const char *name, const char *json_data);
	};
	struct upload_lookup upload_lkt[] = {
		{ "/network/services/update", 5, network_service_update },
		{ "/samba/shares/update"    , 5, samba_share_update     },
		{ "/samba/shares/add"       , 4, samba_share_add        },
		{ "/samba/users/add"        , 4, samba_user_add         },
		{ "/samba/users/update"     , 5, samba_user_update      },
		{ "/samba/groups/add"       , 4, samba_group_add        },
		{ "/samba/groups/update"    , 5, samba_group_update     },
		{ "/restore"                , 2, restore                },
		{ NULL                      , 0, NULL                   }
	};


	path = azy_net_uri_get(net_);
	if( *path != '/' ) {
		UPLOAD_ERROR;
	}
	split = eina_str_split_full(path,
	                            "/",
	                            10,
	                            &nb_params);

	data_recv = azy_server_module_recv_get(module);
	if( ( !data_recv ) ||
	    ( !data_recv->size ) ){
		UPLOAD_ERROR;
	}

	uploaded_data = calloc(1, data_recv->size + 1);
	eina_strlcpy(uploaded_data, (const char *)data_recv->data, data_recv->size + 1);

	for( i = 0; upload_lkt[i].uri; i++ ) {
		if( !strncmp(upload_lkt[i].uri, path, strlen(upload_lkt[i].uri)) ) {
			const char *given_param = NULL;

			if( upload_lkt[i].nb_params == 5 )
				given_param = split[4];

			content = upload_lkt[i].func(given_param, (const char *)uploaded_data);
			goto upload_end_uri;
		}
	
	}

	UPLOAD_ERROR;

upload_end_uri:
	if( got_error == EINA_TRUE ) {
		azy_net_code_set(net_, 400);
		azy_net_header_set(net_, "Content-Type", "text/html");
		content = eina_stringshare_add("Bad request");
	} else {
		azy_net_code_set(net_, 200);
		azy_net_header_set(net_, "Content-Type", "Application/json");
	}
	data_send.data = (unsigned char *)content;
	data_send.size = strlen(content);
	azy_server_module_send(module, net_, &data_send);
    if( split ) {
        free(split[0]);
        free(split);
    }
    if( content   ) eina_stringshare_del(content);
	if( uploaded_data ) free(uploaded_data);
	return EINA_TRUE;
#undef UPLOAD_ERROR
%>

}
